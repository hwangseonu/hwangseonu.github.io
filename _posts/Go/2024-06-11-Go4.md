---
title: 4. Go언어의 타입들
author: hwangseonu
date: 2024-06-11
layout: post
category: go
tags: ["go", "programming"]
---
# Go 언어의 타입들

## 기본 타입

Go 에는 기본적으로  
`논리`, `정수`, `부동소수점수`,  `문자열`, `복소수` 타입이 있다.

### 논리

bool 타입은 불리언(Boolean) 값을 표현하는 데 사용된다.   
`true`나 `false` 두 가지 값 중 하나만 표현할 수 있으므로 가장 작은 크기인 1byte의 크기를 가진다.

```go
var a bool = true
var b bool = false
```

### 정수

정수를 표현하는 타입이다.   
가장 기본적으로는 부호가 있는 정수와 없는 정수로 나눌 수 있으며  
필요한 범위에 따라 다양한 크기의 정수타입을 지원하고 있다.

기본적으로 부호가 있는 정수는 `int`로 표현하며 부호가 없는경우 unsigned를 뜻하는 u를 앞에 붙여 `uint`로 표현한다.  
뒤에 숫자가 붙어 크기를 표현하는 경우도 있는데 `8, 16, 32, 64` bit 의 크기로 나눌 수 있다.

Go 언어에서는 int와 uint의 크기가 플랫폼에 따라 다른데 일반적으로 32비트 또는 64비트 크기를 가진다.

```go 
var i int // 운영체제에 따라 크기가 다름 (32bit, 64bit)
var i8 int8 // 8bit(1byte) 부호있는 정수. -128 ~ 127.
var i16 int16 // 16bit(2byte) 부호있는 정수. -32,768 ~ 32,767
var i32 int32 // 32bit(4byte) 부호있는 정수. -2147483648 ~ 2147483647.
var i64 int64 // 64bit(8byte) 부호있는 정수. -9223372036854775808 ~ 9223372036854775807.

var ui uint // 운영체제에 따라 크기가 다름 (32bit, 64bit)
var ui8 uint8 // 8bit(1byte) 부호없는 정수. 0 ~ 255.
var ui16 uint16 // 16bit(2byte) 부호없는 정수. 0 ~ 65535
var ui32 uint32 // 32bit(4byte) 부호없는 정수. 0 ~ 4294967295.
var ui64 uint64 // 64bit(8byte) 부호앖는 정수. 0 ~ 18446744073709551615.
```

#### 문자

또 다른 정수 타입으로는 문자가 있다.  
왜 문자가 정수이냐 하면 컴퓨터는 문자를 정수로 변환하여 처리하기 때문이다.  
이 때문에 Go언어는 따로 문자 타입을 두지 않고 정수타입에 따로 이름을 붙여 문자 타입으로 사용한다.  

문자 타입에는 byte, rune이 있으며  
byte는 ASCII 문자를 표현하기 위한 정수 타입으로 uint8과 같다. ASCII문자만을 지원하기 때문에 한글은 지원하지 않는다.  
rune은 UTF8 문자를 표현하기 위한 정수 타입으로 int32와 같다. 한글을 지원한다.  

```go
var b byte
var r rune
```

### 부동소수점수

Go에서 실수를 표현하기 위해 IEEE 754 를 따르는 부동소수점수를 사용하며 `단정도 부동 소수점`과 `배정도 부동 소수점`을 지원한다.  

```go
var f32 float32
var f64 float64
```

### 문자열

문자열은 문자들이 연속으로 나열된 것으로 Go언어에서는 기본 타입으로 제공한다.  
문자열은 큰따옴표 `("")`로 감싸 표현할 수 있다.  

Go 언어에는 문자열을 다루기 위한 유틸리티가 많다.  
대표적으로 `strings` 패키지를 보면 문자열을 자르거나 치환하는 등의 다양한 도구를 제공하며
문자열을 다루는 아주 강력한 도구인 `정규표현식`을 사용할 수 있다.  

```go
var s string
```

### 복소수

Go는 다른 복소수를 기본 타입으로 다룰 수 있으며  
복소수를 다루기 위한 다양한 유틸리티를 지원한다.  

```go
var c64 complex64 // 실수부(32bit) + 허수부(32bit)
var c128 complex128 // 실수부(64bit) + 허수부(64bit)
```

real 함수와 imag 함수를 사용하여 각각 실수부와 허수부를 추출 할 수 있다.  

```go
var c64 = 3 + 5i

fmt.Printf("real: %f, imag: %f\n", real(c64), imag(c64)) //출력 real: 3.000000, imag: 5.000000
```

또한 복소수 연산도 지원한다.  

```go
// 두 복소수 생성
var a complex128 = 2 + 3i
var b complex128 = 1 + 1i

// 덧셈 연산
sum := a + b
fmt.Println("Sum:", sum) // 출력: (3+4i)

// 곱셈 연산
product := a * b
fmt.Println("Product:", product) // 출력: (-1+5i)
```

## 컬렉션 (array, slice, map)

컬렉션이란 `데이터를 모아둔 것`이다.

Go언어에선는 기본적으로 `array`, `slice`, `map` 3가지의 컬렉션을 지원한다.  
*(구조체, 채널도 컬렉션의 일종이지만 그 성질이 다르므로 여기서는 다루지 않음)*  

### 순회

컬렉션을 다룰 때 개인적으로 가장 중요한 문법이 `순회` 라고 생각 하기 때문에 순회에 대해 먼저 짚고 넘어가겠다.

이 글에서 다룰 3가지의 컬렉션의 특징은 `순회가능`하다는 것이다.  
순회란 어떤 집합이나 데이터 구조를 한 번씩 반복적으로 방문하고, 각 요소에 대해 작업을 수행하는 것을 의미한다.  

예를 들어, 배열이나 슬라이스, 맵 등의 데이터 구조에 저장된 요소들을 순서대로 읽어들이거나, 그 요소들을 특정한 방식으로 조작하거나 처리하는 것이다.

Go 에서는  `for` 반복문과 `range` 키워드를 통해서 순회를 할 수 있다.  

```go
arr := []int{1, 2, 3, 4, 5}
for index, value := range arr {
    fmt.Printf("인덱스: %d, 값: %d\n", index, value)
}
```


### Array (배열)

`길이가 고정된 배열` 이다.  
여기서 `고정된 길이` 라는 말은 컴파일 시점에 길이가 정해져 있음을 말한다.  
배열은 컴파일 시점에 정확한 길이가 정해져 있어야하며  Go언어 에서 길이가 다른 배열은 완전히 다른 타입으로 취급된다.  

즉, 배열은 길이까지 포함해서 하나의 타입이다.

```
// 길이가 3인 배열 생성
var arr [3]int

// 리터럴로 길이가 3인 배열 생성과 동시에 초기화
arr := [3]int{1,2,3}
```

```go
var arr [3]int // 3 은 배열의 길이

arr[0] = 1
arr[1] = 2
arr[2] = 3

arr[3] = 4 // 컴파일 오류: 배열의 범위를 벗어남
```

```go
func something(a [5]int) {
    print(len(a))
}

var arr [3]int
something(arr) // 컴파일 오류: 배열의 길이가 다름, 완전히 다른 타입으로 취급됨
```

### Slice (슬라이스)

슬라이스는 `가변길이 배열` 이다.  
가변이라는 말 때문에 착각하기 쉽지만  배열 자체의 길이를 능동적으로 줄였다 늘렸다 할 수 있다는 뜻이 아니다.  
배열과는 달리 컴파일 시점에 배열의 길이가 결정되지 않는다는 뜻이다.  

`Slice`는 C99의 `VLA (가변길이배열)` 처럼 실행시점에 배열의 길이를 정해 할당하는 방식이다.  
한번 만들어져 할당된 Slice는 그 길이를 바꿀 수 없고  
`Slice`의 길이를 늘리고 싶다면 길이를 늘린 `새로운 Slice`를 만든 뒤 기존 내용물을 복사하는 방식을 사용해야한다.  

길이를 늘리는 동시에 슬라이스 뒤에 데이터를 추가하고 싶다면  
`append` 함수를 사용할 수 있다.  
`append` 함수를 사용하면 기존의 슬라이스를 복사하여 길이를 늘리고 뒤에 데이터를 추가하여 새로운 슬라이스를 만들어준다.  

`Slice`는 `make` 함수를 통해 생성하거나 리터럴로 생성할 수도 있다.  

```go
// make로 길이가 3인 슬라이스 생성
arr := make([]int, 3)

// 리터럴로 생성
arr := []int{1,2,3}
```

슬라이스는 길이가 가변적이므로 길이에 변수를 넣을 수도 있다.  

```go
func makeSlice(l int) []int {
    s := make([]int, l) // 컴파일 시점에 길이를 알 수 없음
    
    for i := 0; i < l; i++ {
        s[i] = i + 1
    }
    
    return s
}

s := makeSlice(3)

fmt.Println(len(s)) // 실행 시점에 길이가 정해짐, 3

s[3] = 4 // 런타임 패닉 : index out of range, 한번 만들어진 Slice는 길이가 변하지 않음

newSlice = append(s, 4, 5) // 기존의 슬라이스의 길이는 증가하지 않음, 길이가 늘어난 새로운 슬라이스를 생성

fmt.Println(len(s))     // 길이: 3
fmt.Println(len(newSlice))     // 길이: 5
```

`Slice`는 길이가 가변적인 탓에 컴파일 시점에는 파악할 수 없는`Runtime Panic`을 일으킬 수 있으므로 사용에 각별한 주의가 필요하다.  
사용할 때 항상 길이 체크를 하는 습관을 들이는 편이 좋다.  

### Map

`Map`은 `Key-Value`쌍의 집합으로 크기가 동적으로 늘었다 줄었다 할 수 있다.  
`Key`는 하나의 `Map`에서 `고유한 값`이고 `Value`는 `Key와 1대1 대응`되는 값이다.  

예를 들어 `유저 아이디`와 `유저 데이터`의 관계같은 경우 `Map` 을 활용하면 쉽게 다룰 수 있다.  

Go는 `Hash Table`을 통해 `Map`을 구현하고 있다.  

`Map`또한 `make`함수를 통해 생성할 수 있다.  

```go
// 맵을 선언
var m map[string]int

// make 함수를 사용하여 맵 생성
m = make(map[string]int)

// 리터럴을 사용하여 맵 생성
m := map[string]int{"one": 1, "two": 2, "three": 3}
```

`Map`에 있는 정보를 가져오거나 추가, 삭제할 수 있다.
Key가 존재하지 않아도 기본값을 반환하니 주의해야한다.  
대신, Key가 존재하지 않으면 두번째 값으로 false를 반환한다.  

```go
a, ok := m["one"]
b, ok := m["uno"] //Key가 존재하지 않으면 기본값 0과 false가 반환된다.
```

```go
m["four"] = 4 // Map에 데이터 추가
delete(m, "two") // Map에서 Key 가 0인 데이터를 삭제한다.
```

`Map` 또한 range 키워드로 순회할 수 있다.

```go
for key, value := range m {
    fmt.Println("키:", key, "값:", value)
}
```

## 마치며

다음에는 사용자 지정 타입과 Struct, interface를 알아볼 차례다.  
Go에서 가장 중요한 개념 중 하나 라고 생각하므로 다음 포스팅에는 조금 더 신경을 써야 할 것 같다.
