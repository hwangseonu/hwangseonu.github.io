---
title: 3. Go언어의 타입시스템
author: hwangseonu
date: 2024-06-04
layout: post
category: go
tags: ["go", "programming"]
---

## 타입

`타입` 또는 `형` 이라고 부르는 개념은 프로그래밍에서 메모리에 저장된 데이터의 종류를 의미하며, 데이터를 어떻게 저장하고 해석할지를 결정한다.

예를들어 같은 정수라 하더라도 크기가 달라 메모리에서 차지하는 공간이 다를 수 있고  
같은 데이터라도 정수일때와 문자일때 해석하는 방법이 다르다.  

```go
// 아래의 두 변수는 같은 "정수형" 변수 이지만 그 크기가 다르다.
// 같은 타입이라면 더 크기가 큰 자료형이 최대값, 최소값의 범위가 크다
var a int32 //32bit의 메모리 공간을 가진다.
var b int64 //64bit의 메모리 공간을 가진다.
```

```go
// 아래의 두 변수는 메모리상에서 크기도 완전히 같은 데이터이지만
// 타입이 달라 표현하는 방식이 달라진다.
var a int32 = 65
var b rune = 'A'
```

## 타입 시스템

타입 시스템은 개발자가 코드를 작성할 때 프로그램의 동작과 유지보수를 더욱 예측 가능하게 만들어주는 중요한 개념으로 타입을 정의하고 조작하는 체계이다.  

프로그래밍 언어에는 `변수`, `상수`, `함수 매개변수`, `함수 반환 값` 등이 있고 이는 각자 다른 타입을 가지고 저장되고 표현된다.  

타입 시스템은 이러한 타입들을 어떻게 부여, 해석, 추론할 것인지 정의한 시스템이다.   

### 정적타입 (Statically Typed)

Go 언어는 정적 타입 언어이다.  
정적 타입 언어는 `변수`, `상수`, `함수 매개변수`, `함수 반환 값` 등의 타입이 컴파일 하는 시점에 결정되는 프로그래밍 언어를 말한다.  

Go 언어에서는 변수를 선언할 때 변수의 타입이 결정되며 이는 절대 바뀌지 않는다.  

```go
// 각각 int, float64, string 타입의 변수 선언
var x int = 10
var y float64 = 5.5
var z string = "Hello"

// 변수의 타입을 변경하는 것은 불가능
x = 20.5 // Error cannot use 20.5 (type float64) as type int in assignment

```

마찬가지로 함수의 매개변수와 반환값 또한 컴파일 시점에 결정되어 있어야 하며 이를 명시적으로 표시 해 주어야한다.  
다른 타입의 매개변수를 사용하거나, 반환하려하면 오류가 난다.  

아래의 함수는 `int`타입의 매개변수를 받아 `string`타입의 데이터를 반환하는 함수이다.

```go
func something(a int) string {
    return fmt.Sprintf("Hello, %d\n", a)
}

something("1") // Error: 매개변수의 타입이 맞지 않음

func something(a int) string {
    return 12345 // Error: 반환 타입이 맞지 않음
}
```

이처럼 Go 언어에서는 모든 데이터가 타입을 가지며 이는 컴파일 하는 시점에 이미 결정되어 있어야 한다.  

#### 타입 추론

Go 언어는 정적 타입 언어이다.  
이는 Go 언어로 사용할 때 모든 데이터의 타입을 고려하고 명시적으로 표기해줘야함을 뜻한다.  
이는 너무 불편하다. 그래서, Go 언어는 이 문제를 `타입 추론`으로 해결하고 있다.  

타입 추론 이란 프로그래머가 변수의 타입을 지정하지 않아도 컴파일러가 자동으로 변수의 타입을 추론하여 지정하는 것을 말한다.  

Go 에서는 `선언과 동시에 초기화` 하는 경우 타입 추론을 사용할 수 있다.  
즉 `var =`를 사용하거나 `:=`연산자를 사용하는 경우 변수의 타입을 명시적으로 지정하지 않고도 컴파일러가 우측의 값을 통해 자동으로 타입을 판단하여 변수의 타입으로 사용하게 된다.  

보통의 경우 변수는 `선언과 동시에 초기화` 되기 때문에 Go 언어에서는 타입 추론을 적극적으로 사용할 수 있다. 

어차피 직접 초기화 하지 않아도 기본값으로 초기화 되기 때문에 선언대입(:=) 연산자를 적극적으로 활용하는 것이 좋다

```go
var a = 64 // 대입 연산자 우측 데이터가 정수형이기 때문에 기본 정수형인 int32 또는 int64로 변수의 타입이 정해짐

b := 64 // 위와 완전히 같음 (위의 선언의 축약형)

s := "string" // 대입 연산자 우측 데이터가 문자열이기 때문에 문자열 타입으로 변수가 선언됨
```

### 강타입 (Strongly Typed)

위에서 Go 언어에서 변수는 선언될 때 타입이 결정되며 이는 절대 바뀌지 않는다고 했는데 이는 `강타입` 언어의 특징이다.  

Go 언어는 타입에 대해서 매우 엄격하다. 변수의 타입은 선언 시에 결정되며 이를 절대 바꿀 수 없다.

또한, Go 언어에서는 서로 다른 타입의 데이터간의 연산이 불가능하다. 
이를 위해선 반드시 명시적인 형변환이 선행되어야 한다. 타입 안정성을 높여 예기치 못한 오류나 버그를 방지하는데 도움이 되지만 코딩하는데 더 신경써야하고 서로 다른 타입의 연산이 필요할 때 마다 명시적으로 형변환을 해야하는 번거로움이 있다.  

```go
// 정수형 변수 선언
var num1 int = 10
var num2 int = 20
    
// 정수형 변수끼리의 연산
sum := num1 + num2
fmt.Println("Sum:", sum)

// 형변환
var x int = 10
var y float64 = 5.5

// 정수형 변수를 실수형 변수로 명시적 형변환
result := float64(x) + y
fmt.Println("Result:", result)
```

만일 위에서 다음과 같이 명시적 형변환을 하지 않은 채 다른 타입 간의 연산을 시도한다면 컴파일 할 때 오류가 발생할 것이다.

```go
// 정수형과 실수형을 혼합하여 연산하는데 명시적 형변환이 없음
result := x + y // 오류: 타입 불일치
fmt.Println("Result:", result)
```
```
invalid operation: x + y (mismatched types int and float64)
```

### 덕 타이핑 (Duck Typing)

턱 타이핑은 Go 언어의 중요한 특징 중 하나로 객체가 수행하는 동작에 초점을 맞춰 타입을 결정하는 시스템이다. 

덕 타이핑은 앞에서 말한 변수와 함수에 관련된 이야기가 아닌  
객체의 타입을 결정하는 방법에 관한 이야기이다.  

아직 인터페이스에 대해 다루지 않았으므로 이번에는 간단한 개념만 살펴보고 자세한 설명은 다음에 하도록 한다.

덕 타이핑은 `Duck Test`에서 비롯된 개념으로 

> 만약 어떤 새가 오리처럼 걷고, 오리처럼 소리를 내고, 오리처럼 행동한다면, 그것은 오리로 간주할 수 있다.  

라는 개념에 착안하여 Go 언어에서는 객체의 타입을 결정할 때 어떤 인터페이스를 `상속` 해서 구현하는 지가 아닌 어떤 인터페이스의 `메서드가 구현`되어 있는가에 초첨을 맞추고 있다.  

즉, 객체가 어떤 인터페이스의 메서드를 구현하고 있다면 그 인터페이스 타입으로 사용할 수 있는 것이다.

## 끝마치며

오랜만에 글을 쓰는 것 같은데  
아직 내용이 한참 남은 것 같다.  
꾸준하게 글을 쓰겠다고 마음 먹었었지만 외적인 문제와 의지의 문제로 지속하기 어려웠었다. 작심삼일이라는 말처럼 금방 흐지부지 되고 말았다.

작심삼일도 3일마다 하면 그만이다.  
앞으로는 꾸준히 글을 쓸 수 있도록 노력해보자.

다음글에서는 Go 언어의 기본타입에 대해서 알아보자.
